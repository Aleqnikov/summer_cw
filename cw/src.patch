diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/checker/base_checker.c ./src/checker/base_checker.c
--- /tmp/tmp.TWsp1NfOBI/checker/base_checker.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/checker/base_checker.c	2025-04-07 18:14:48.062599552 +0300
@@ -0,0 +1,67 @@
+/**
+* @file base_checker.c
+ * @brief  Содержит главную функцию для проверки данных.
+ */
+
+#include "base_checker.h"
+
+/**
+ * @brief Данная функция является проверкой корректности переданнх значений, соответствие режимам и т.п.
+ * Простые проверки производит сама, но более ветвистые перераспределяет по зависимым вспомогательным функциям.
+ *
+ * Данная функция является главной функцией для проверки корректности заполенности полей переданного экземпляра
+ * структуры. Проверят пустое ли поле названия входного файла. На совпадение названия начального и конечного названия.
+ * проверят на корректность расширения.
+ * Используется как функция проверки заполненности структуры.
+ *
+ * @param figure Указатель на проверяемый объект
+ * @return Если все проверки прошли, то ноль, в ином случае код ошибки.x
+ */
+int base_checker(object_t* figure) {
+    if (figure->start_filename == NULL) {
+        fprintf(stderr, "Error: Не было введено имя файла!\n");
+        return 1;
+    }
+
+    if (strcmp(figure->start_filename, figure->finish_filename) == 0) {
+        fprintf(stderr, "Error: Начальные и стартовые имена совпадают!\n");
+        return 1;
+    }
+
+    if (check_dt_bmp(figure->start_filename)) {
+        fprintf(stderr, "Error: Изначальный файл не имеет расширение .bmp!\n");
+        return 1;
+    }
+
+    if (check_dt_bmp(figure->finish_filename)) {
+        fprintf(stderr, "Error: Конечный файл не имеет расширение .bmp!\n");
+        return 1;
+    }
+
+    int res_check = 0;
+    switch (figure->mod) {
+        case rect:
+            res_check = check_rectangle(figure);
+            break;
+        case ornament:
+            res_check = check_ornament(figure);
+            break;
+        case rotate:
+            res_check = check_rotate(figure);
+            break;
+        case circ:
+            res_check = check_circle(figure);
+            break;
+        case info:   // Избыточно, так как уже проверяется корректность имени файла.
+            res_check = check_info(figure);
+            break;
+        case help:
+            printf("sosat\n");
+            break;
+        default:
+            fprintf(stderr, "Error: Не выбран режим работы!\n");
+            return 1;
+    }
+
+    return res_check;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/checker/base_checker.h ./src/checker/base_checker.h
--- /tmp/tmp.TWsp1NfOBI/checker/base_checker.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/checker/base_checker.h	2025-04-07 18:14:33.065682956 +0300
@@ -0,0 +1,10 @@
+#ifndef BASE_CHECKER_H
+#define BASE_CHECKER_H
+
+#include "../structures.h"
+
+#include "check_functions.h"
+
+int base_checker(object_t*);
+
+#endif // BASE_CHECKER_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/checker/check_functions.c ./src/checker/check_functions.c
--- /tmp/tmp.TWsp1NfOBI/checker/check_functions.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/checker/check_functions.c	2025-04-07 18:14:48.062599552 +0300
@@ -0,0 +1,169 @@
+/**
+* @file check_functions.c
+ * @brief  Содержит  функции для проверки данных.
+ */
+
+
+#include "check_functions.h"
+
+/**
+ * @brief Данная функция проверяет корректность заполненности структуры для режима работы --rect.
+ *
+ * Данная функция проверяет инициализированны ли поля необходимые для режима  --rect в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на структуру.
+ * @return Ноль или единица
+ */
+bool check_rectangle(object_t* figure) {
+    if (checker_left_up(figure)) return 1;
+    if (checker_right_down(figure)) return 1;
+    if (checker_thinckness(figure)) return 1;
+    if (checker_color(figure)) return 1;
+    if (checker_fill(figure)) return 1;
+
+    if (figure->y_center != base_coords_val ||  figure->x_center != base_coords_val) return 2;
+    if (figure->radius != base_radius_val ||  figure->angle != base_angle_val) return 2;
+    if (figure->pattern != none ||  figure->count != base_count_val) return 2;
+
+    return 0;
+}
+
+/**
+ * @brief Данная функция проверяет корректность заполнености структуры для режима работы --circle.
+ *
+ * Данная функция проверяет инициализированны ли поля необходимые для режима  --circle в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на структуру.
+ * @return Ноль или единица
+ */
+bool check_circle(object_t* figure) {
+    // Проверяем специфические параметры
+    if (figure->x_center == INT_MIN || figure->y_center == INT_MIN) {
+        fprintf(stderr, "Error: Вы не выбрали центр окружности!\n");
+        return 1;
+    }
+
+    if (figure->radius == -1 ) {
+        fprintf(stderr, "Error: Вы не выбрали радиус окружности!\n");
+        return 1;
+    }
+
+    if (checker_thinckness(figure)) return 1;
+    if (checker_color(figure)) return 1;
+    if (checker_fill(figure)) return 1;
+
+    if (figure->x_right_down != base_coords_val ||  figure->x_left_up != base_coords_val) return 2;
+    if (figure->y_right_down != base_coords_val ||  figure->y_left_up != base_coords_val) return 2;
+    if (figure->pattern != none ||  figure->count != base_count_val || figure->angle != base_angle_val) return 2;
+    return 0;
+}
+
+/**
+ * @brief Проверят корректность полей для --ornament.
+ *
+ * Данная функция проверяет инициализированны ли поля необходимые для режима  --ornament в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект.
+ * @return Ноль в случае удачи в ином случае единица.
+ */
+int check_ornament(object_t* figure) {
+
+    if (figure->color_r == base_color_val || figure->color_g == base_color_val || figure->color_b == base_color_val) {
+        fprintf(stderr, "Error: Вы не ввели цвет для фигуры!\n");
+        return 1;
+    }
+
+    if (figure->y_center != base_coords_val ||  figure->x_center != base_coords_val) return 2;
+    if (figure->radius != base_radius_val ||  figure->angle != base_angle_val) return 2;
+    if (figure->fill != false ||  figure->color_fill_b != base_color_val ||  figure->color_fill_g != base_color_val ||  figure->color_fill_r != base_color_val) return 2;
+    if (figure->x_right_down != base_coords_val ||  figure->x_left_up != base_coords_val) return 2;
+    if (figure->y_right_down != base_coords_val ||  figure->y_left_up != base_coords_val) return 2;
+
+
+    switch (figure->pattern) {
+        case rectangle:
+            if (checker_color(figure)) return 1;
+            if (checker_thinckness(figure)) return 1;
+
+            if (figure->count == base_count_val) {
+                fprintf(stderr, "Error: Вы не ввели количество!\n");
+                return 1;
+            }
+            break;
+        case circle:
+            if (figure->thinckness != base_thinckness_val || figure->count != base_count_val) return 2;
+            break;
+        case semicircle:
+            if (checker_color(figure)) return 1;
+            if (checker_thinckness(figure)) return 1;
+            if (figure->count == base_count_val) {
+                fprintf(stderr, "Error: Вы не ввели количество фигур!\n");
+                return 1;
+            }
+            break;
+        case none:
+            fprintf(stderr, "Error: не был введён орнамента режим!\n");
+            return 1;
+        default:
+            fprintf(stderr, "Error: Невозможная ошибка в проверка орнамента.\n");
+            return 1
+        ;
+    }
+
+    return 0;
+}
+
+/**
+ * @brief Проверят корректность полей для --rotate.
+ *
+ * Данная функция проверяет инициализированны ли поля необходимые для режима  --rotate в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект.
+ * @return Ноль в случае удачи в ином случае единица.
+ */
+int check_rotate(object_t* figure) {
+    if (checker_left_up(figure)) return 1;
+
+    if (checker_right_down(figure)) return 1;
+
+    if (figure->angle == -1 ) {
+        fprintf(stderr, "Error: Вы не выбрали угол поворота!\n");
+        return 1;
+    }
+
+    if (figure->y_center != base_coords_val ||  figure->x_center != base_coords_val) return 2;
+    if (figure->radius != base_radius_val ||  figure->count != base_count_val) return 2;
+    if (figure->pattern != none ||  figure->count != base_count_val) return 2;
+    if (figure->fill != false ||  figure->color_fill_b != base_color_val ||  figure->color_fill_g != base_color_val ||  figure->color_fill_r != base_color_val) return 2;
+    if (figure->thinckness != base_thinckness_val ||  figure->color_b != base_color_val ||  figure->color_g != base_color_val ||  figure->color_r != base_color_val) return 2;
+
+    return 0;
+}
+
+
+/**
+ * @brief Проверят корректность полей для --help.
+ *
+ * Данная функция проверяет инициализированны ли поля необходимые для режима  --help в переданной ей структуре.
+ * А также проверяет, что никакие лишние поля не инициализированны.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект.
+ * @return Ноль в случае удачи в ином случае единица.
+ */
+int check_info(object_t* figure) {
+    if (figure->y_center != base_coords_val ||  figure->x_center != base_coords_val) return 2;
+    if (figure->fill != false ||  figure->color_fill_b != base_color_val ||  figure->color_fill_g != base_color_val ||  figure->color_fill_r != base_color_val) return 2;
+    if (figure->radius != base_radius_val ||  figure->count != base_count_val ||  figure->angle != base_angle_val) return 2;
+    if (figure->pattern != none ||  figure->count != base_count_val) return 2;
+    if (figure->thinckness != base_thinckness_val ||  figure->color_b != base_color_val ||  figure->color_g != base_color_val ||  figure->color_r != base_color_val) return 2;
+    if (figure->x_right_down != base_coords_val ||  figure->x_left_up != base_coords_val) return 2;
+    if (figure->y_right_down != base_coords_val ||  figure->y_left_up != base_coords_val) return 2;
+    if(strcmp(figure->finish_filename, "out.bmp") != 0) return 2;
+
+    return 0;
+}
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/checker/check_functions.h ./src/checker/check_functions.h
--- /tmp/tmp.TWsp1NfOBI/checker/check_functions.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/checker/check_functions.h	2025-04-07 18:14:33.065682956 +0300
@@ -0,0 +1,14 @@
+#ifndef CHECK_FUNCTIONS_H
+#define CHECK_FUNCTIONS_H
+
+#include "base_checker.h"
+#include "help_functions.h"
+
+bool check_rectangle(object_t*);
+bool check_circle(object_t*);
+int check_ornament(object_t*);
+int check_rotate(object_t* figure);
+int check_info(object_t*);
+
+#endif // CHECK_FUNCTIONS_H
+
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/checker/help_functions.c ./src/checker/help_functions.c
--- /tmp/tmp.TWsp1NfOBI/checker/help_functions.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/checker/help_functions.c	2025-04-07 18:14:33.065682956 +0300
@@ -0,0 +1,119 @@
+/**
+* @file help_functions.c
+ * @brief  Содержит вспомогательные функции для проверки данных.
+ */
+
+#include "help_functions.h"
+
+/**
+ * @brief Данная функция проверяет, имеет ли файл расширение .bmp.
+ *
+ * Данная функция проверят, является ли корректным расширение файла, в данном случае bmp.
+ * Используется как вспомогательная функция при проверке переданных аргументов.
+ *
+ * @param filename Имя файла.
+ * @return Да или нет
+ */
+bool check_dt_bmp(const char* filename) {
+    size_t len = strlen(filename);
+    return !(len >= 4 && strcmp(filename + len - 4, ".bmp") == 0);
+}
+
+
+/**
+ * @brief Проверят на корректность заполненость цветов для определённого режима.
+ *
+ * Данная функция проверяет на корректность заполненность полей цвета в переданной структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект
+ * @return Правда или ложь.
+ */
+bool checker_color(object_t* figure) {
+    if (figure->color_r == -1 || figure->color_g == -1 || figure->color_b == -1) {
+        fprintf(stderr, "Error: Вы не ввели цвет для фигуры!\n");
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ * @brief Данная функция проверяет на корректность заполненность поля thinckness.
+ *
+ * Данная функция проверяет корректность заполненности поля thinckness в переданной ей структуре. Проверяет
+ * инициализированно ли поле, а также на то, больше нуля ли значение поля.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект
+ * @return Правду либо ложь.
+ */
+bool checker_thinckness(object_t* figure) {
+    if (figure->thinckness == -1) {
+        fprintf(stderr, "Error: Вы не ввели толщину линии!\n");
+        return 1;
+    }
+
+    if (figure->thinckness <= 0) {
+        fprintf(stderr, "Error: Передана неккоректная толщина линии, должна быть больше нуля!\n");
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ * @brief Данная функция проверяет на корректность заполненность полей координат левой точки.
+ *
+ * Данная функция проверяет инициализированные ли координаты в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект
+ * @return Правду либо ложь.
+ */
+bool checker_left_up(object_t* figure) {
+    if (figure->x_left_up == INT_MIN || figure->y_left_up == INT_MIN) {
+        fprintf(stderr, "Error: Вы не ввели координаты для левой верхней точки!\n");
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ * @brief Данная функция проверяет на корректность заполненность полей координат правой точки.
+ *
+ * Данная функция проверяет инициализированные ли координаты в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект
+ * @return Правду либо ложь.
+ */
+bool checker_right_down(object_t* figure) {
+    if (figure->x_right_down == INT_MIN || figure->y_right_down == INT_MIN) {
+        fprintf(stderr, "Error: Вы не ввели координаты для правой нижней точки!\n");
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ * @brief Данная функция проверяет на корректность заполненность полей заливки и цвета заливки.
+ *
+ * Данная функция проверяет инициализированные ли цвета в переданной ей структуре.
+ * Используется как вспомогательная функция.
+ *
+ * @param figure Указатель на объект
+ * @return Правду либо ложь.
+ */
+bool checker_fill(object_t* figure) {
+    if (figure->fill && (figure->color_fill_b == -1 || figure->color_fill_r == -1 || figure->color_fill_g == -1)) {
+        fprintf(stderr, "Error: Вы выбрали режим заливки, но не выбрали цвет!\n");
+        return 1;
+    }
+
+    if (!figure->fill && (figure->color_fill_b != -1 || figure->color_fill_r != -1 || figure->color_fill_g != -1)) {
+        fprintf(stderr, "Error: Вы не выбрали режим заливки, но выбрали цвет!\n");
+        return 1;
+    }
+
+    return 0;
+}
+
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/checker/help_functions.h ./src/checker/help_functions.h
--- /tmp/tmp.TWsp1NfOBI/checker/help_functions.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/checker/help_functions.h	2025-04-07 18:14:33.069016349 +0300
@@ -0,0 +1,13 @@
+#ifndef HELP_FUNCTIONS_H
+#define HELP_FUNCTIONS_H
+
+#include "base_checker.h"
+
+bool check_dt_bmp(const char*);
+bool checker_color(object_t*);
+bool checker_thinckness(object_t*);
+bool checker_left_up(object_t*);
+bool checker_right_down(object_t*);
+bool checker_fill(object_t*);
+
+#endif // HELP_FUNCTIONS_H
\ В конце файла нет новой строки
Двоичные файлы /tmp/tmp.TWsp1NfOBI/.DS_Store и ./src/.DS_Store различаются
Двоичные файлы /tmp/tmp.TWsp1NfOBI/i1.bmp и ./src/i1.bmp различаются
Двоичные файлы /tmp/tmp.TWsp1NfOBI/i2.bmp и ./src/i2.bmp различаются
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas.c ./src/Image/canvas.c
--- /tmp/tmp.TWsp1NfOBI/Image/canvas.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas.c	2025-04-07 22:16:49.337057430 +0300
@@ -0,0 +1,72 @@
+/**
+* @file canvas.c
+* @brief Главная функция, которая рисует на изоборжаении.
+* 
+* Используется в главном файле, при рисовании на изображении.
+*/
+
+#include "canvas.h"
+
+/**
+ * @brief Главная функция, которая оперирует вспомогательными функциями, и рисует на изображении.
+ * 
+ * Используется в функции main.
+ * @param Структура фигуры.
+ */
+int canvas_logic(object_t figure) {
+    BitmapFileHeader bmfh;
+    BitmapInfoHeader bmih;
+    Rgb **data = NULL;
+
+    if(!read_bmp(figure.start_filename, &bmfh, &bmih, &data)){
+        fprintf(stderr, "Error: Не удалось считать данные из файла.\n");
+        return 0;
+    }
+
+    Rgb color_fill = (Rgb){figure.color_fill_b, figure.color_fill_g, figure.color_fill_r};
+    Rgb color =  (Rgb){figure.color_b, figure.color_g, figure.color_r};
+
+    figure.y_center = bmih.height - figure.y_center;
+    figure.y_left_up = bmih.height - figure.y_left_up;
+    figure.y_right_down = bmih.height - figure.y_right_down;
+
+    switch (figure.mod) {
+        case rect:
+            draw_rectangle(&data, bmih, figure, color_fill, color);
+            break;
+        case ornament:
+            switch (figure.pattern) {
+                case circle:
+                    circle_ornament(&data, bmih, color);
+                    break;
+                case rectangle:
+                    rectangle_ornament(&data, bmih, figure, color);
+                    break;
+                case semicircle:
+                    semi_circle_ornament(&data, bmih, figure.count, figure.thinckness, color);
+                    break;
+            }
+            break;
+        case rotate:
+            data = rotate_area(&data, bmih, figure);
+            if (data == NULL)
+                return 1;
+            break;
+        case circ:
+            draw_circle(&data, bmih, color, color_fill, figure);
+            break;
+        case info:
+            print_file_header(bmfh);
+            print_info_header(bmih);
+            break;
+    }
+
+    if (!write_bmp(figure.finish_filename, &bmfh, &bmih, data)) 
+        return 1;
+    
+    for (int i = 0; i < (bmih.height); i++) 
+        free(data[i]);
+    free(data);
+
+    return 0;
+}
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_circle.c ./src/Image/canvas_circle.c
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_circle.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_circle.c	2025-04-08 11:32:13.524199018 +0300
@@ -0,0 +1,144 @@
+/**
+* @file canvas_circle.c
+* @brief Файл, который содержит функию для рисовании круга на изображении, а также вспомогательные для этого функции.
+* 
+* Используется при рисовании круга.
+*/
+
+#include "canvas_circle.h"
+
+/**
+ * @brief Данная функция является реализацией алгоритма Брезенхема, добавляет точки в массив. Возвращает его длину.
+ * 
+ * Используется для получения координат окружности.
+ * 
+ * @param Получает на вход радиус и массив точек.
+ */
+int circ_bre(int rad, point_t* circle){
+    int x = 0;
+    int y = rad;
+    int d = 3 - 2 * rad;
+
+    int index = 0;
+
+    while (x <= y){
+        circle[index].x = x;
+        circle[index].y = y;
+
+        index++;
+
+        if (x != y){
+            circle[index].x = y;
+            circle[index].y = x;
+            index++;
+        }
+
+        if (d < 0) {
+            d = d + 4 * x + 6;
+        }
+        else {
+            d = d + 4 * (x - y) + 10;
+            y--;
+        }
+        x++;
+    }
+
+    return index;
+}
+
+int draw_fill_circle(Rgb*** data, circle_t circle, BitmapInfoHeader bmih, Rgb color){
+
+
+        for(int i = 0; i < circle.len_array; i++){
+            int x_val = circle.points[i].x;
+            int y_val = circle.points[i].y;
+
+            point_t point1 = {circle.x_center + x_val, circle.y_center + y_val};
+            point_t point2 = {circle.x_center + x_val, circle.y_center - y_val};
+            point_t point3 = {circle.x_center - x_val, circle.y_center + y_val};
+            point_t point4 = {circle.x_center - x_val, circle.y_center - y_val};
+
+            point_t point5 = {circle.x_center + y_val, circle.y_center + x_val};
+            point_t point6 = {circle.x_center + y_val, circle.y_center - x_val};
+            point_t point7 = {circle.x_center - y_val, circle.y_center + x_val};
+            point_t point8 = {circle.x_center - y_val, circle.y_center - x_val};
+
+
+            
+                draw_line((line_t){.thickness = 1, .point_1 = point1, .point_2 = point2}, data, bmih, color);
+                draw_line((line_t){.thickness = 1, .point_1 = point2, .point_2 = point3}, data, bmih, color);
+                draw_line((line_t){.thickness = 1, .point_1 = point3, .point_2 = point4}, data, bmih, color);       
+                draw_line((line_t){.thickness = 1, .point_1 = point1, .point_2 = point4}, data, bmih, color);
+            
+    
+            
+                draw_line((line_t){.thickness = 1, .point_1 = point5, .point_2 = point6}, data, bmih, color);
+                draw_line((line_t){.thickness = 1, .point_1 = point6, .point_2 = point7}, data, bmih, color);
+                draw_line((line_t){.thickness = 1, .point_1 = point7, .point_2 = point8}, data, bmih, color);
+                draw_line((line_t){.thickness = 1, .point_1 = point5, .point_2 = point8}, data, bmih, color);
+            
+            
+        }
+    
+
+    
+}
+
+int draw_thincless_circle(Rgb*** data, circle_t* array, BitmapInfoHeader bmih, Rgb color){
+    for(int i = 0; i < array->len_array; i++){
+        int x_val = array->points[i].x;
+        int y_val = array->points[i].y;
+
+        int x_c = array->x_center;
+        int y_c = array->y_center;
+
+        object_t circle1 = {.radius = array->thickness / 2, .x_center = x_c + x_val, .y_center = y_c + y_val, .thinckness = 1, .fill = true, .thinckness = 0};
+        object_t circle3 = {.radius = array->thickness / 2, .x_center = x_c - x_val, .y_center = y_c + y_val, .thinckness = 1, .fill = true, .thinckness = 0};
+        object_t circle2 = {.radius = array->thickness / 2, .x_center = x_c + x_val, .y_center = y_c - y_val, .thinckness = 1, .fill = true, .thinckness = 0};
+        object_t circle4 = {.radius = array->thickness / 2, .x_center = x_c - x_val, .y_center = y_c - y_val, .thinckness = 1, .fill = true, .thinckness = 0};
+
+        object_t circle5 = {.radius = array->thickness / 2, .x_center = x_c + y_val, .y_center = y_c + x_val, .thinckness = 1, .fill = true, .thinckness = 0};
+        object_t circle6 = {.radius = array->thickness / 2, .x_center = x_c + y_val, .y_center = y_c - x_val, .thinckness = 1, .fill = true, .thinckness = 0};
+        object_t circle7 = {.radius = array->thickness / 2, .x_center = x_c - y_val, .y_center = y_c + x_val, .thinckness = 1, .fill = true, .thinckness = 0};
+        object_t circle8 = {.radius = array->thickness / 2, .x_center = x_c - y_val, .y_center = y_c - x_val, .thinckness = 1, .fill = true, .thinckness = 0};
+
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle1);
+        draw_circle(data, bmih,(Rgb){0,0,0}, color, circle2);
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle3);
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle4);
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle5);
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle6);
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle7);
+        draw_circle(data, bmih, (Rgb){0,0,0}, color, circle8);
+    }
+}
+
+
+/**
+ * @brief Данная функия рисует окружность.
+ * 
+ * Используется при рисовании круга круга.
+ * 
+ * @param Массив точек,цвет, цвет заливки, InfoHeader, фигуру.
+ */
+int draw_circle(Rgb*** data, BitmapInfoHeader bmih, Rgb color, Rgb color_fill, object_t figure) {
+
+    circle_t circle = {
+        .points = malloc(sizeof(point_t) * figure.radius * 8),
+        .radius = figure.radius,
+        .x_center = figure.x_center,
+        .y_center = figure.y_center,
+        .thickness = figure.thinckness,
+    };
+
+    circle.len_array = circ_bre(circle.radius, circle.points);
+
+    if (figure.fill)
+        draw_fill_circle(data, circle, bmih, color_fill);
+
+    if(figure.thinckness != 0)
+        draw_thincless_circle(data, &circle, bmih, color);
+
+    free(circle.points);
+    return 0;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_circle.h ./src/Image/canvas_circle.h
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_circle.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_circle.h	2025-04-07 22:33:07.396455929 +0300
@@ -0,0 +1,13 @@
+#ifndef CANVAS_CIRCLE_H
+#define CANVAS_CIRCLE_H
+
+#include "image_functions.h"
+#include "help_canvas_fns.h"
+#include "canvas_line.h"
+
+int circ_bre(int, point_t*);
+int draw_fill_circle(Rgb***, circle_t, BitmapInfoHeader, Rgb);
+int draw_circle(Rgb***, BitmapInfoHeader, Rgb, Rgb, object_t);
+int draw_thincless_circle(Rgb***, circle_t*, BitmapInfoHeader, Rgb);
+
+#endif //CANVAS_CIRCLE_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas.h ./src/Image/canvas.h
--- /tmp/tmp.TWsp1NfOBI/Image/canvas.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas.h	2025-04-07 22:59:43.298856977 +0300
@@ -0,0 +1,11 @@
+#ifndef CANVAS_H
+#define CANVAS_H
+
+#include "image_functions.h"
+#include "canvas_circle.h"
+#include "canvas_ornament.h"
+#include "canvas_rect.h"
+#include "canvas_rotate.h"
+
+int canvas_logic(object_t);
+#endif //CANVAS_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_line.c ./src/Image/canvas_line.c
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_line.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_line.c	2025-04-08 11:32:56.368250453 +0300
@@ -0,0 +1,45 @@
+#include "canvas_line.h"
+
+
+void draw_line(line_t line, Rgb*** data, BitmapInfoHeader bmih, Rgb color){
+    
+
+    int x_0 = get_value_range(min(line.point_1.x, line.point_2.x), 0, bmih.width, line.thickness / 2);
+    int y_0 = get_value_range(min(line.point_1.y, line.point_2.y), 0, bmih.height, line.thickness / 2);
+
+    int x_1 = get_value_range(max(line.point_1.x, line.point_2.x), 0, bmih.width, line.thickness / 2);
+    int y_1 = get_value_range(max(line.point_1.y, line.point_2.y), 0, bmih.height, line.thickness / 2);
+
+
+    int dx = x_1 - x_0;
+    int dy = y_1 - y_0;
+    int err = dx - dy;
+
+    int sx = 1;
+    int sy = 1;
+
+    while (1) {
+        if(line.thickness == 1){
+            if(check_coord(y_0, x_0, bmih.height, bmih.width)) 
+            (*data)[y_0][x_0] = color;
+        } else{
+            draw_circle(data, bmih, color, color, (object_t){.x_center = x_0, .y_center = y_0, .radius = line.thickness / 2, .thinckness = 0, .fill = true});
+        }
+        
+        
+        if (x_0 == x_1 && y_0 == y_1)
+            break;
+
+        int e2 = 2 * err;
+
+        if (e2 > -dy) {
+            err -= dy;
+            x_0 += sx;
+        }
+
+        if (e2 < dx) {
+            err += dx;
+            y_0 += sy;
+        }
+    }
+}
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_line.h ./src/Image/canvas_line.h
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_line.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_line.h	2025-04-07 22:17:58.918601882 +0300
@@ -0,0 +1,10 @@
+#ifndef CANVAS_LINE_H
+#define CANVAS_LINE_H
+
+#include "image_functions.h"
+#include "help_canvas_fns.h"
+#include "canvas_circle.h"
+
+void draw_line(line_t, Rgb***, BitmapInfoHeader, Rgb);
+
+#endif //CANVAS_LINE_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_ornament.c ./src/Image/canvas_ornament.c
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_ornament.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_ornament.c	2025-04-07 18:14:48.062599552 +0300
@@ -0,0 +1,111 @@
+/**
+* @file canvas_ornament.c
+* @brief Файл, который содержит функию для рисовании орнаментов на изображении.
+* 
+* Используется при рисовании орнаментов.
+*/
+
+#include "canvas_ornament.h"
+
+/**
+ * @brief Данная функция рисует орнамент прямоугольник на изображении.
+ *
+ * Используется как функция рисования орнамента.
+ * 
+ * @param Получает на вход указатель на массив данных, фигуры, и InfoHeader а также цвет.
+ */
+int rectangle_ornament(Rgb*** data, BitmapInfoHeader bmih, object_t figure, Rgb color) {
+    int thickness = (figure.thinckness  % 2 == 0) ? figure.thinckness + 1 : figure.thinckness;
+    int diff = thickness / 2;
+
+    for (int i = 0; i < figure.count; i++) {
+
+        const object_t tmp_figure = {
+            .fill = figure.fill,
+            .thinckness = figure.thinckness,
+            .x_left_up = diff,
+            .x_right_down = bmih.width - diff,
+            .y_left_up = bmih.height - diff,
+            .y_right_down = diff
+        };
+
+        draw_rectangle(data, bmih, tmp_figure, (Rgb){0,0,0}, color); // Второй цвет никогда не будет использован
+        diff += 2*thickness;
+    }
+    return 1;
+}
+
+/**
+ * @brief Данная функция рисует орнамент круг на изображении.
+ *
+ * Используется как функция рисования орнамента.
+ * 
+ * @param Получает на вход указатель на массив данных, фигуры, и InfoHeader а также цвет.
+ */
+int circle_ornament(Rgb*** data, BitmapInfoHeader bmih, Rgb color) {
+    int x_c = (bmih.width + 1) / 2;
+    int y_c = (bmih.height + 1) / 2;
+    int min_radius = x_c < y_c ? x_c : y_c;
+    int max_radius =  x_c + y_c;
+
+    object_t tmp_figure = {
+        .fill = false,
+        .thinckness = 2*(max_radius - min_radius),
+        .x_center = x_c,
+        .y_center = y_c,
+        .radius = max_radius,
+    };
+
+    draw_circle(data, bmih, color, (Rgb){0,0,0}, tmp_figure);
+
+}
+
+/**
+ * @brief Данная функция рисует орнамент из нескольких кругов на изображении.
+ *
+ * Используется как функция рисования орнамента.
+ * 
+ * @param Получает на вход указатель на массив данных, фигуры, и InfoHeader а также цвет, количество и толщину линии.
+ */
+int semi_circle_ornament(Rgb*** data, BitmapInfoHeader bmih, int count, int thickness, Rgb color) {
+    const int width_step = (bmih.width + count * 2 - 1) / (count * 2);
+    const int height_step = (bmih.height + count * 2 - 1) / (count * 2);
+
+    int current_x = width_step;
+    int current_y = bmih.height - height_step - 1;
+
+    const Rgb bg_color = {0, 0, 0};
+    const bool no_fill = false;
+
+    for (int i = 0; i < count; i++) {
+
+        object_t horizontal_circle = {
+            .thinckness = thickness,
+            .fill = no_fill,
+            .radius = width_step,
+            .x_center = current_x,
+            .y_center = 0  
+        };
+        draw_circle(data, bmih, color, bg_color, horizontal_circle);
+
+        horizontal_circle.y_center = bmih.height;  
+        draw_circle(data, bmih, color, bg_color, horizontal_circle);
+
+        object_t vertical_circle = {
+            .thinckness = thickness,
+            .fill = no_fill,
+            .radius = height_step,
+            .x_center = 0,
+            .y_center = current_y
+        };
+        draw_circle(data, bmih, color, bg_color, vertical_circle);
+
+        vertical_circle.x_center = bmih.width;
+        draw_circle(data, bmih, color, bg_color, vertical_circle);
+
+        current_x += 2 * width_step;
+        current_y -= 2 * height_step;
+    }
+
+    return 0;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_ornament.h ./src/Image/canvas_ornament.h
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_ornament.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_ornament.h	2025-04-07 18:14:33.065682956 +0300
@@ -0,0 +1,12 @@
+#ifndef CANVAS_ONAMENT_H
+#define CANVAS_ONAMENT_H
+
+#include "image_functions.h"
+#include "canvas_circle.h"
+#include "canvas_rect.h"
+
+int rectangle_ornament(Rgb***, BitmapInfoHeader, object_t, Rgb);
+int circle_ornament(Rgb***, BitmapInfoHeader, Rgb);
+int semi_circle_ornament(Rgb***, BitmapInfoHeader, int, int, Rgb);
+
+#endif //CANVAS_ONAMENT_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_rect.c ./src/Image/canvas_rect.c
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_rect.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_rect.c	2025-04-07 22:14:35.013940631 +0300
@@ -0,0 +1,45 @@
+/**
+* @file canvas_rect.c
+* @brief Файл, который содержит функию для рисовании прямоугольника на изображении.
+* 
+* Используется при рисовании прямоугольника.
+*/
+
+#include "canvas_rect.h"
+
+
+
+/**
+ * @brief Данная функция рисует прямоугольник на изображении.
+ *
+ * Используется как функция рисования.
+ * 
+ * @param Получает на вход указатель на массив данных, фигуры, и InfoHeader.
+ */
+void draw_rectangle(Rgb*** data, BitmapInfoHeader bmih, object_t figure, Rgb color_fill, Rgb color) {
+
+    int thickness = figure.thinckness;
+    int x_0 = min(figure.x_left_up, figure.x_right_down); 
+    int x_1 = max(figure.x_left_up, figure.x_right_down);
+    int y_0 = min(figure.y_left_up, figure.y_right_down);
+    int y_1 = max(figure.y_left_up, figure.y_right_down);
+
+    // Остявляем такой какая есть
+    if (figure.fill) {
+        for(int y = y_0; y <= y_1 ; y++) {
+            for(int x = x_0; x <= x_1 ; x++)
+                if(check_coord(y, x, bmih.height, bmih.width)) (*data)[y][x] = color_fill;
+        }
+    }
+
+    point_t point1 = {x_0, y_0};
+    point_t point2 = {x_0, y_1};
+    point_t point3 = {x_1, y_1};
+    point_t point4 = {x_1, y_0};
+
+
+    draw_line((line_t){.thickness = figure.thinckness, .point_1 = point1, .point_2 = point2}, data, bmih, color);
+    draw_line((line_t){.thickness = figure.thinckness, .point_1 = point2, .point_2 = point3}, data, bmih, color);
+    draw_line((line_t){.thickness = figure.thinckness, .point_1 = point3, .point_2 = point4}, data, bmih, color);
+    draw_line((line_t){.thickness = figure.thinckness, .point_1 = point1, .point_2 = point4}, data, bmih, color);
+}
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_rect.h ./src/Image/canvas_rect.h
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_rect.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_rect.h	2025-04-07 22:19:48.047612298 +0300
@@ -0,0 +1,10 @@
+#ifndef CANVAS_RECT_H
+#define CANVAS_RECT_H
+
+#include "image_functions.h"
+#include "help_canvas_fns.h"
+#include "canvas_line.h"
+
+void draw_rectangle(Rgb***, BitmapInfoHeader, object_t, Rgb, Rgb);
+
+#endif //CANVAS_RECT_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_rotate.c ./src/Image/canvas_rotate.c
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_rotate.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_rotate.c	2025-04-08 11:33:49.282469815 +0300
@@ -0,0 +1,54 @@
+/**
+* @file canvas_rotate.c
+* @brief Файл, который содержит функия для поворота части изображения.
+* 
+* Используется при повороте изобрежения.
+*/
+
+#include "canvas_rotate.h"
+
+/**
+ * @brief Данная функция переворачивает часть изображения.
+ *
+ * При помощи преобразований плоскости, мы меняем координаты точек, и затем ставим её на новое место.
+ * Т.е x = xcosa + ysina, y = -xsina + ycosa. Используется в файле canvas.ACCESSX_MAX_TABLESIZE
+ * 
+ * @param Получает на вход указатель на массив данных, фигуры, и InfoHeader.
+ */
+Rgb** rotate_area(Rgb*** data, BitmapInfoHeader bmih, object_t figure){
+
+    Rgb** new_data = copy_array(*data, bmih.height, bmih.width);
+    if (new_data == NULL)
+        return NULL;
+
+    
+    int x_left = get_value_range(figure.x_left_up, 0, bmih.width, figure.thinckness / 2);
+    int x_right = get_value_range(figure.x_right_down, 0, bmih.width, figure.thinckness / 2);
+    
+    int y_up = get_value_range(figure.y_left_up, 0, bmih.height, figure.thinckness / 2);
+    int y_down = get_value_range(figure.y_right_down, 0, bmih.height, figure.thinckness / 2);
+
+    int x_center = (x_left + x_right) / 2;
+    int y_center = (y_up + y_down) / 2;
+
+
+    for (int y = min(y_up, y_down); y < max(y_up, y_down); y++) {
+        for (int x = min(x_left, x_right); x < max(x_left, x_right) ; x++) {
+            
+            int x_shifted = x - x_center;
+            int y_shifted = y - y_center;
+
+            int x_new = (int)((x_shifted * custom_cos(figure.angle) + y_shifted * custom_sin(figure.angle)) + x_center);
+            int y_new = (int)((-x_shifted *custom_sin(figure.angle)) + y_shifted * custom_cos(figure.angle) + y_center);
+
+            if(check_coord(y_new, x_new, bmih.height, bmih.width))  new_data[y_new][x_new] = (*data)[y][x];
+
+        }
+    }
+
+    for (int i = 0; i < (bmih.height); i++)
+        free((*data)[i]);
+    free(*data);
+
+    return new_data;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/canvas_rotate.h ./src/Image/canvas_rotate.h
--- /tmp/tmp.TWsp1NfOBI/Image/canvas_rotate.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/canvas_rotate.h	2025-04-07 18:14:33.065682956 +0300
@@ -0,0 +1,9 @@
+#ifndef CANVAS_ROTATE_H
+#define CANVAS_ROTATE_H
+
+#include "image_functions.h"
+#include "help_canvas_fns.h"
+
+Rgb** rotate_area(Rgb***, BitmapInfoHeader, object_t);
+
+#endif //CANVAS_ROTATE_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/help_canvas_fns.c ./src/Image/help_canvas_fns.c
--- /tmp/tmp.TWsp1NfOBI/Image/help_canvas_fns.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/help_canvas_fns.c	2025-04-08 11:29:30.264789106 +0300
@@ -0,0 +1,104 @@
+/**
+* @file help_canvas_fns.c
+ * @brief  Содержит вспомогательные функции для рисования фигур на изображении.
+ * 
+ * Используется в файлах canvas_[...].
+ */
+
+#include "help_canvas_fns.h"
+
+/**
+ * @brief Данная функция проверяет, выходит ли за пределы изображения координаты.
+ * 
+ * Используется при рисовании различных фигур.
+ * 
+ * @param Получает координаты точки, и характеристики изображения.
+ */
+bool check_coord(int y, int x, int height, int weight){
+    if((x >= 0 && x < weight) && (y >= 0 && y < height))
+        return 1;
+    return 0;
+}
+
+/**
+ * @brief Данная функция копирует переданный ей массив типа Rgb и затем возварщает ссылку на новый скопированный массив.
+ * 
+ * Используется в функции поворота части изображения, для того чтобы получить новый массив, и поместить на 
+ * него новые пиксели, перемещённой области.
+ * 
+ * @param Массив данных, который нужно скопировать, и его хараектеристики, высота и длина.
+ */
+Rgb** copy_array(Rgb** data, int height, int width){
+    Rgb** new_array = NULL;
+    new_array = (Rgb** )(malloc(sizeof(Rgb* ) * (height)));
+
+    if (new_array == NULL)
+        return NULL;
+
+    for (int i = 0; i < (height); i++) {
+        (new_array)[i] = (Rgb *)malloc(width * sizeof(Rgb));
+    }
+
+    for(int i = 0; i < height; i++){
+        for(int j = 0; j < width; j++)
+            new_array[i][j] = data[i][j];
+    }
+
+    return new_array;
+}
+
+/**
+* @brief Функция синуса, в зависимости от переданного угла возвращает значение.
+* Используется в функции поворота части изображения, для применения аффинных преобразований.
+* @param Получает угол 90 180 или 270 градусов. В ином случае не делает ничего, ибо другого угла передано быть не может.
+*/
+int custom_cos(int angle) {
+    switch (angle) {
+        case 90:
+            return 0;
+        case 180:
+            return 1;
+        case 270:
+            return 0;
+    }
+}
+
+/**
+* @brief Функция синуса, в зависимости от переданного угла возвращает значение.
+* Используется в функции поворота части изображения, для применения аффинных преобразований.
+* @param Получает угол 90 180 или 270 градусов. В ином случае не делает ничего, ибо другого угла передано быть не может.
+*/
+int custom_sin(int angle) {
+    switch (angle) {
+        case 90:
+            return -1;
+        case 180:
+            return 0;
+        case 270:
+            return 1;
+    }
+}
+
+/**
+ * @brief Данная функция проверяет входит ли функция в диапозон.
+ * 
+ * Используется в функции rotate.
+ */
+int get_value_range(int value, int low, int high, int thinkless){
+
+    if(value >= low - thinkless && value <= high + thinkless)
+        return value;
+    if(value > high + thinkless) return high + thinkless;
+    if(value < low - thinkless) return low - 1 - thinkless;
+}
+
+int max(int x, int y){
+    return x >= y? x: y;
+}
+
+int min (int x, int y){
+    return x <= y ? x : y;
+}
+
+
+
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/help_canvas_fns.h ./src/Image/help_canvas_fns.h
--- /tmp/tmp.TWsp1NfOBI/Image/help_canvas_fns.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/help_canvas_fns.h	2025-04-08 11:30:04.355362950 +0300
@@ -0,0 +1,14 @@
+#ifndef HELP_CANVAS_FNS_H
+#define HELP_CANVAS_FNS_H
+
+#include "image_functions.h"
+
+bool check_coord(int, int, int, int);
+Rgb** copy_array(Rgb**, int, int);
+int custom_cos(int);
+int custom_sin(int angle);
+int get_value_range(int, int, int, int);
+int max(int , int);
+int min (int, int);
+
+#endif //HELP_CANVAS_FNS_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/image_functions.c ./src/Image/image_functions.c
--- /tmp/tmp.TWsp1NfOBI/Image/image_functions.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/image_functions.c	2025-04-07 22:06:56.142883464 +0300
@@ -0,0 +1,158 @@
+/**
+* @file image_functionss.c
+ * @brief  Содержит  функции считывания и записи изображения, а также функции для
+ * вывода информации о изображении.
+ * 
+ * Используется в файле canvas.c.
+ */
+
+#include "image_functions.h"
+
+/**
+ * @breif Данная функция получает на вход длину изображения и возвращает значение паддинга.
+ * 
+ * Используется при записи и считывания изображения.
+ */
+int get_padding(unsigned int width){
+    return ((width*3 + 3) & (~3));
+}
+
+/**
+* @brief Данная функция считывает изображение.
+* 
+* Используется для считывания изображения.
+* 
+* @param Получает название файла,указатель на Header файла, и Header информации файла, указатель на массив.
+*/
+bool read_bmp(const char* filename, BitmapFileHeader* file_header, BitmapInfoHeader* info_header, Rgb*** data){
+    FILE* file = fopen(filename, "rb");
+
+    if(!file){
+        fprintf(stderr, "Error: Не удалось открыть файл!\n");
+        return 0;
+    }
+
+    fread(file_header, sizeof(BitmapFileHeader), 1, file);
+    fread(info_header, sizeof(BitmapInfoHeader), 1, file);
+
+    if(file_header->signature != 0x4D42){
+        fprintf(stderr, "Error: Файл не является bmp.\n");
+        return 0;
+    }
+
+    if(info_header->bitsPerPixel != 24){
+        fprintf(stderr, "Error: Программа поддерживает только 24 бита на пиксель!\n");
+        return 0;
+    }
+
+
+    if(info_header->compression != 0){
+        fprintf(stderr, "Error: Программа не обрабатывает изображения со сжатием!\n");
+        return 0;
+    }
+
+    fseek(file, file_header->pixelArrOffset, SEEK_SET);
+    int row_padded = get_padding(info_header->width);
+
+    *data = (Rgb** )(malloc(sizeof(Rgb* )* info_header->height));
+
+    if(!*data){
+        fprintf(stderr, "Error: Не удалось выделить память под массив пикселей!\n");
+        return 0;
+    }
+
+    for (int i = 0; i < info_header->height; i++){
+        (*data)[i] = (Rgb *)malloc(info_header->width * sizeof(Rgb));
+
+        if(!(*data)[i]){
+            fprintf(stderr, "Error: Не удалось выделить память под строку пикселей!.\n");
+            return 0;
+        }
+    }
+
+    for(int i = 0; i < info_header->height; i++){
+        for(int j = 0; j < info_header->width; j++)
+            fread(&(*data)[i][j], sizeof(Rgb), 1, file);
+        
+        fseek(file, row_padded - info_header->width*3, SEEK_CUR);       // Пропускаем лишние данные выравнивания.
+    }
+
+    fclose(file);
+    return 1;
+}
+
+/**
+ * @brief Данная функция записывает переданные данные в файл.
+ * 
+ * @param Получает на вход название файла, указатели на headerы и массив пикселей.
+ */
+bool write_bmp(const char* filename, const BitmapFileHeader* bmfh, const BitmapInfoHeader* bmih, Rgb** data){
+    FILE* file = fopen(filename, "wb");
+
+    if(!file){
+        fprintf(stderr, "Error: Не удалось открыть файл для записи выходного изображения.\n");
+        return 1;
+    }
+
+    fwrite(bmfh, sizeof(BitmapFileHeader), 1, file);
+    fwrite(bmih, sizeof(BitmapInfoHeader), 1, file);
+
+    fseek(file, bmfh->pixelArrOffset, SEEK_SET);
+
+    int row_paded = get_padding(bmih->width);
+
+    for(int y = 0; y < bmih->height; y++){
+        for(int x = 0; x < bmih->width; x++)
+            fwrite(&data[y][x], sizeof(Rgb), 1, file);
+        
+        // Добавляеся padding для выравнивания строки кратности 4.
+        unsigned char padding = 0;
+        for(int i = 0; i < row_paded - bmih->width*3; i++)
+            fwrite(&padding, sizeof(unsigned char), 1, file);
+    }
+
+    fclose(file);
+    return 0;
+}
+
+
+
+/**
+ * @brief Функция которая печатает информацию headera файла.
+ * 
+ * Используется в функции печатающей информацию о файле.
+ * 
+ * @param Получает на вход FileHeader.
+ */
+void print_file_header(BitmapFileHeader bmfh){
+    printf("signature:          \t%x (%hu)\n", bmfh.signature, bmfh.signature);
+    printf("filesize:           \t%x (%u)\n", bmfh.filesize, bmfh.filesize);
+    printf("reserved1:          \t%x (%hu)\n", bmfh.reserved1, bmfh.reserved1);
+    printf("reserved2:          \t%x (%hu)\n", bmfh.reserved2, bmfh.reserved2);
+    printf("pixelArrOffset:     \t%x (%u)\n", bmfh.pixelArrOffset, bmfh.pixelArrOffset);
+}
+
+
+/**
+ * @brief Функция которая печатает информацию headera информации.
+ * 
+ * Используется в функции печатающей информацию о файле.
+ * 
+ * @param Получает на вход InfoHeader.
+ */
+void print_info_header(BitmapInfoHeader bmih){
+    printf("headerSize:         \t%x (%u)\n", bmih.headerSize, bmih.headerSize);
+    printf("width:              \t%x (%u)\n", bmih.width, bmih.width);
+    printf("height:             \t%x (%u)\n", bmih.height, bmih.height);
+    printf("planes:             \t%x (%hu)\n", bmih.planes, bmih.planes);
+    printf("bitsPerPixel:       \t%x (%hu)\n", bmih.bitsPerPixel, bmih.bitsPerPixel);
+    printf("compression:        \t%x (%u)\n", bmih.compression, bmih.compression);
+    printf("imageSize:          \t%x (%u)\n", bmih.imageSize, bmih.imageSize);
+    printf("xpixelsPerMeter:    \t%x (%u)\n", bmih.xPixelsPerMeter, bmih.xPixelsPerMeter);
+    printf("ypixelsPerMeter:    \t%x (%u)\n", bmih.yPixelsPerMeter, bmih.yPixelsPerMeter);
+    printf("colorsInColorTable: \t%x (%u)\n", bmih.colorsInColorTable, bmih.colorsInColorTable);
+    printf("importantColorCount:\t%x (%u)\n", bmih.importantColorCount, bmih.importantColorCount);
+}
+
+
+
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Image/image_functions.h ./src/Image/image_functions.h
--- /tmp/tmp.TWsp1NfOBI/Image/image_functions.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Image/image_functions.h	2025-04-07 22:07:08.963086513 +0300
@@ -0,0 +1,15 @@
+#ifndef IMAGE_FUNCTIONS_H
+#define IMAGE_FUNCTIONS_H
+
+#include "../structures.h"
+
+int get_padding(unsigned int);
+bool write_bmp(const char*, const BitmapFileHeader*, const BitmapInfoHeader*, Rgb**);
+bool read_bmp(const char*, BitmapFileHeader*, BitmapInfoHeader*, Rgb***);
+void print_file_header(BitmapFileHeader);
+void print_info_header(BitmapInfoHeader);
+
+
+
+
+#endif //IMAGE_FUNCTIONS_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/main.c ./src/main.c
--- /tmp/tmp.TWsp1NfOBI/main.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/main.c	2025-04-07 18:28:34.856761965 +0300
@@ -0,0 +1,76 @@
+/**
+* @file main.с
+ * @brief Основной файл программы.
+ */
+
+#include "structures.h"
+#include "parcer/parcer.h"
+#include "checker/base_checker.h"
+#include "Image/canvas.h"
+
+/**
+ * @brief Функция конструктор заполняет структуру базовыми значениями, предполагается, что такие значения не могут
+ * получится в случае парсера, поэтому можно будет проверить, ввел ли пользователь тому или иному полю значение.
+ *
+ * Данная функция получая на вход структуру заполняет её поля некоторыми - невозможными значениями, для того чтобы
+ * при проверке структуры на корректность переданных аргументов можно было понять, было ли заполнено пользователем
+ * или иное поле. Используется при создании структуры для заполнения её базовыми значениями. Не всегда он нужен, тк
+ * иногда может заранее подразумеватся, что структура заполненна корректно.
+ *
+ * @param obj Объект, который нужно инициализировать.
+ */
+void constuctor(object_t* obj) {
+    obj->mod = None;
+    obj->start_filename = NULL;
+    obj->finish_filename = "out.bmp";
+    obj->x_left_up = base_coords_val;
+    obj->y_left_up = base_coords_val;
+    obj->x_right_down = base_coords_val;
+    obj->y_right_down = base_coords_val;
+    obj->pattern = none;
+    obj->count = base_count_val;
+    obj->angle = base_angle_val;
+    obj->x_center = base_coords_val;
+    obj->y_center = base_coords_val;
+    obj->radius = base_radius_val;
+    obj->thinckness = base_thinckness_val;
+    obj->fill = false;
+    obj->color_fill_b = base_color_val;
+    obj->color_fill_r = base_color_val;
+    obj->color_fill_g = base_color_val;
+    obj->color_r = base_color_val;
+    obj->color_g = base_color_val;
+    obj->color_b = base_color_val;
+}
+
+int main(int argc, char* argv[]){
+    printf("Course work for option 5.1, created by Ivan Aleinikov\n");
+
+    object_t* figure = malloc(sizeof(object_t));
+    constuctor(figure);
+
+    
+
+    switch (base_parser(figure, argc, argv)) {
+        case 1:
+            return 41;
+        case 2:
+            return 0;
+    }
+        
+    switch (base_checker(figure)) {
+        case 1:
+            help_print();
+            return 42;
+        case 2:
+            fprintf(stderr, "Error: были переданны неккоректные параметры для выборанной вами функци!\n");
+            help_print();
+            return 43;
+    }
+
+    canvas_logic(*figure);
+
+    free(figure);
+
+    return 0;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/Makefile ./src/Makefile
--- /tmp/tmp.TWsp1NfOBI/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ ./src/Makefile	2025-04-07 22:21:55.783589082 +0300
@@ -0,0 +1,64 @@
+CC = gcc
+DEV = -Wall -Wextra
+CFLAGS =  -std=c99
+OBJ = main.o parcer/parcer_assets.o  parcer/parcer.o  parcer/additional.o parcer/help.o checker/base_checker.o checker/check_functions.o checker/help_functions.o Image/canvas.o Image/canvas_circle.o Image/canvas_ornament.o Image/canvas_rect.o Image/canvas_rotate.o Image/canvas_line.o Image/help_canvas_fns.o Image/image_functions.o
+EXEC = cw
+
+all: $(EXEC)
+
+$(EXEC): $(OBJ)
+	$(CC) $(CFLAGS) -o $(EXEC) $(OBJ)
+
+main.o: main.c parcer/parcer.h structures.h checker/base_checker.h Image/canvas.h
+	$(CC) $(CFLAGS) -c main.c -o main.o
+
+parcer/parcer.o: parcer/parcer.c parcer/parcer.h parcer/parcer_assets.h parcer/additional.h parcer/help.h structures.h
+	$(CC) $(CFLAGS) -c parcer/parcer.c -o parcer/parcer.o
+
+parcer/parcer_assets.o: parcer/parcer_assets.c  parcer/parcer_assets.h parcer/parcer.h
+	$(CC) $(CFLAGS) -c parcer/parcer_assets.c -o parcer/parcer_assets.o
+
+parcer/additional.o: parcer/additional.c  parcer/additional.h parcer/parcer.h
+	$(CC) $(CFLAGS) -c parcer/additional.c -o parcer/additional.o
+
+parcer/help.o: parcer/help.c  parcer/help.h parcer/parcer.h
+	$(CC) $(CFLAGS) -c parcer/help.c -o parcer/help.o
+
+checker/base_checker.o: checker/base_checker.c  checker/base_checker.h structures.h checker/check_functions.h
+	$(CC) $(CFLAGS) -c checker/base_checker.c -o checker/base_checker.o
+
+checker/check_functions.o: checker/check_functions.c  structures.h checker/check_functions.h checker/help_functions.h
+	$(CC) $(CFLAGS) -c checker/check_functions.c -o checker/check_functions.o
+
+checker/help_functions.o: checker/help_functions.c  structures.h checker/check_functions.h checker/help_functions.h
+	$(CC) $(CFLAGS) -c checker/help_functions.c -o checker/help_functions.o
+
+Image/canvas.o: Image/canvas.c structures.h Image/image_functions.h Image/canvas_circle.h Image/canvas_ornament.h Image/canvas_rect.h Image/canvas_rotate.h  Image/canvas.h
+	$(CC) $(CFLAGS) -c Image/canvas.c -o Image/canvas.o
+
+Image/canvas_circle.o: Image/canvas_circle.c Image/canvas_circle.h Image/help_canvas_fns.h Image/image_functions.h structures.h Image/canvas_line.h
+	$(CC) $(CFLAGS) -c Image/canvas_circle.c -o Image/canvas_circle.o
+
+Image/canvas_ornament.o: Image/canvas_ornament.c Image/canvas_ornament.h Image/image_functions.h Image/canvas_circle.h Image/canvas_rect.h structures.h
+	$(CC) $(CFLAGS) -c Image/canvas_ornament.c -o Image/canvas_ornament.o
+
+Image/canvas_rect.o: Image/canvas_rect.c Image/canvas_rect.h structures.h Image/help_canvas_fns.h Image/image_functions.h Image/canvas_line.h
+	$(CC) $(CFLAGS) -c Image/canvas_rect.c -o Image/canvas_rect.o
+
+Image/canvas_rotate.o: Image/canvas_rotate.c Image/canvas_rotate.h structures.h Image/help_canvas_fns.h Image/image_functions.h
+	$(CC) $(CFLAGS) -c Image/canvas_rotate.c -o Image/canvas_rotate.o
+
+Image/help_canvas_fns.o: Image/help_canvas_fns.c Image/help_canvas_fns.h structures.h Image/image_functions.h
+	$(CC) $(CFLAGS) -c Image/help_canvas_fns.c -o Image/help_canvas_fns.o
+
+Image/image_functions.o: Image/image_functions.c Image/image_functions.h structures.h
+	$(CC) $(CFLAGS) -c Image/image_functions.c -o Image/image_functions.o
+
+Image/canvas_line.o:  Image/canvas_line.c Image/canvas_line.h Image/help_canvas_fns.h Image/image_functions.h structures.h
+	$(CC) $(CFLAGS) -c Image/canvas_line.c -o Image/canvas_line.o
+
+test:
+	../tests.sh
+
+clean:
+	rm -f $(OBJ) $(EXEC)
\ В конце файла нет новой строки
Двоичные файлы /tmp/tmp.TWsp1NfOBI/output.bmp и ./src/output.bmp различаются
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/additional.c ./src/parcer/additional.c
--- /tmp/tmp.TWsp1NfOBI/parcer/additional.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/additional.c	2025-04-07 18:14:48.062599552 +0300
@@ -0,0 +1,107 @@
+/**
+* @file additional.c
+* @brief В данном файле находятся вспомогательные функции для функций парсера.
+*/
+
+#include "additional.h"
+
+/**
+ * @brief Данная функция проверяет корректность аргументов, проверяет что строку полностью состоит из чисел
+ *
+ * Функция, которая проверят, что переданная строка является числом.
+ * Используется в других функция при проверке на корректность аргументов.
+ *
+ * @param str строка, которую нужно проверить
+ * @return Если число, то возвращает единицу.
+ */
+bool is_number(const char *str) {
+    if (!str || *str == '\0') return 0;
+
+    while (*str) {
+        if (!isdigit(*str) && *str != '-') return 0;
+        str++;
+    }
+    return 1;
+}
+
+/**
+ * @brief Данная функция проверяет корректность аргументов парсера, которые заданы через точку (x.y).
+ *
+ * Функция проверят, что количество точек в данной строке соответствует нужному количеству.
+ * В контексте данной программы она проверят, что строка соответствует формату <x.y>. То есть используется при
+ * проверке корректности координат, и цветов. В основном используется как вспомогательная функция.
+ *
+ * @param str Строка, содержимое которое необходимо проверить на корректность.
+ * @param count_dots Количество точек, которое должно быть в строке.
+ * @return
+ */
+bool is_correct_dots(const char *str, int count_dots) {
+    char* dot = strchr(str, '.');
+
+    for (int i = 0; i < count_dots; i++) {
+        if (!dot) return 0;  
+        dot = strchr(dot + 1, '.');
+    }
+
+    if (!str || *str == '\0')
+        return 0;
+
+    while (*str) {
+        if (!isdigit(*str) && *str != '-' && *str != '.') return 0;
+        str++;
+    }
+
+    return !(dot == NULL);
+}
+
+/**
+ * @brief Вспомогательная функция, помогает определить корректность цвета, диапазон, и количество считанного.
+ *
+ *  Данная функция проверяет корректность переданных значений цветов.
+ *  Используется как вспомогательная функция.
+ *
+ * @param count Количество прочитанных аргументов.
+ * @param red Число красного цвета.
+ * @param green Число зелёного цвета.
+ * @param blue Число синего цвета.
+ * @return Булевое значение.
+ */
+bool check_colors( int red, int green, int blue) {
+    if (red < 0 || red > 255 || blue < 0 || blue > 255 || green < 0 || green > 255) {
+        fprintf(stderr, "Error: цвета переданы в неккоректном формате! Каждый должен быть в диапазоне [0, 255]");
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/**
+ * @brief Данная функция устанавливает режим, который должна нарисовать программа.
+ * 
+ * Используется в парере для установки режима.
+ * 
+ * @param mode Режим
+ * @param figure объект, в который устанавливается режим.
+ */
+bool set_mode(const char* mode, object_t* figure){
+    if(figure->mod != None)
+        return 1;
+
+    if( strcmp(mode, "rect") == 0)
+        figure->mod = rect;
+
+    if( strcmp(mode, "ornament") == 0)
+        figure->mod = ornament;
+
+    if( strcmp(mode, "circle") == 0)
+        figure->mod = circ;
+
+    if( strcmp(mode, "rotate") == 0)
+        figure->mod = rotate;
+
+    if( strcmp(mode, "info") == 0)
+        figure->mod = info;
+
+    return 0;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/additional.h ./src/parcer/additional.h
--- /tmp/tmp.TWsp1NfOBI/parcer/additional.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/additional.h	2025-04-07 18:14:33.069016349 +0300
@@ -0,0 +1,11 @@
+#ifndef ADDITIONAL_H
+#define ADDITIONAL_H
+
+#include "parcer.h"
+
+bool is_number(const char*);
+bool is_correct_dots(const char*, int);
+bool check_colors(int, int, int);
+bool set_mode(const char*, object_t*);
+
+#endif // ADDITIONAL_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/help.c ./src/parcer/help.c
--- /tmp/tmp.TWsp1NfOBI/parcer/help.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/help.c	2025-04-07 18:14:48.062599552 +0300
@@ -0,0 +1,54 @@
+/**
+* @file help.c
+* @brief В данном файле находятcя справка о программе.
+*/
+
+#include "help.h"
+
+/**
+ * @brief Данная функция является справкой для команд, которые поддерживает приложение.
+ */
+void help_print(void) {
+    printf("╭━━╮╭━╮╭━┳━━━╮╭━━━┳━━━┳━━┳━━━━┳━━━┳━━━╮\n"
+            "┃╭╮┃┃┃╰╯┃┃╭━╮┃┃╭━━┻╮╭╮┣┫┣┫╭╮╭╮┃╭━╮┃╭━╮┃\n"
+            "┃╰╯╰┫╭╮╭╮┃╰━╯┃┃╰━━╮┃┃┃┃┃┃╰╯┃┃╰┫┃╱┃┃╰━╯┃\n"
+            "┃╭━╮┃┃┃┃┃┃╭━━╯┃╭━━╯┃┃┃┃┃┃╱╱┃┃╱┃┃╱┃┃╭╮╭╯\n"
+            "┃╰━╯┃┃┃┃┃┃┃╱╱╱┃╰━━┳╯╰╯┣┫┣╮╱┃┃╱┃╰━╯┃┃┃╰╮\n"
+            "╰━━━┻╯╰╯╰┻╯╱╱╱╰━━━┻━━━┻━━╯╱╰╯╱╰━━━┻╯╰━╯\n");
+    printf("\n\n Справка о программе!\n");
+
+    printf("Данная программа обладает флагами:\n"
+           "    -h, --help                                                  Печатает информационную справку.\n"
+           "    --info <file.bmp>                                       Печатает информацию о bmp файле.\n\n"
+           "    --rect  [options]\n"
+           "        -l --left_up <x.y>                                      Устанавливает координаты левой точки.\n"
+           "        -r --right_down <x.y>                                   Устанавливает координаты правой нижней точки.\n"
+           "        -t --thickness <num>                                    Устанавливает толщину линий.\n"
+           "        -с --color <rrr.ggg.bbb>                                Устанавливет цвет линии.\n"
+           "        -f --fill                                               Устанавливает нужна ли заливка.\n"
+           "        -F --fill_color <rrr.ggg.bbb>                           Устанавливает цвета заливки.\n\n"
+           "        -o --output <file.bmp>                                  Устанавливает название выходного файла.\n"
+           "        -i --input <file.bmp>                                   Устанавливает название входного файла.\n"
+           "    --ornament [options] \n"
+           "        -p --pattern [rectangle, circle, cemicircles]            Устанавливает режим орнамента.\n"
+           "        -t --thickness <num>                                    Устанавливает тольщину линии.\n"
+           "        -c --color <rrr.ggg.bbb>                                Устанавливет цвет линии.\n"
+           "        -C --count <num>                                        Устанавливает количество.\n"
+           "        -o --output <file.bmp>                                  Устанавливает название выходного файла.\n"
+           "        -i --input <file.bmp>                                   Устанавливает название входного файла.\n"
+           "    --rotate [options] \n"
+           "        -l --left_up <x.y>                                      Устанавливает координаты левой точки.\n"
+           "        -r --right_down <x.y>                                   Устанавливает координаты правой нижней точки.\n"
+           "        -a --angle <num>                                        Устанавливает угол, может быть 90, 180, 270\n"
+           "        -o --output <file.bmp>                                  Устанавливает название выходного файла.\n"
+           "        -i --input <file.bmp>                                   Устанавливает название входного файла.\n"
+           "    --circle [options]\n"
+           "        -n --center <x.y>                                       Устанавливает центр окружности.\n"
+           "        -R --radius <num>                                       Устанавливает радиус окружности.\n"
+           "        -t --thickness <num>                                    Устанавливает толщину линий.\n"
+           "        -c --color <rrr.ggg.bbb>                                Устанавливет цвет линии.\n"
+           "        -f --fill                                               Устанавливает нужна ли заливка.\n"
+           "        -F --fill_color <rrr.ggg.bbb>                           Устанавливает цвета заливки.\n\n"
+           "        -o --output <file.bmp>                                  Устанавливает название выходного файла.\n"
+           "        -i --input <file.bmp>                                   Устанавливает название входного файла.\n");
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/help.h ./src/parcer/help.h
--- /tmp/tmp.TWsp1NfOBI/parcer/help.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/help.h	2025-04-07 18:14:33.069016349 +0300
@@ -0,0 +1,8 @@
+#ifndef HELP_H
+#define HELP_H
+
+#include "parcer.h"
+
+void help_print();
+
+#endif // HELP_H
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/parcer_assets.c ./src/parcer/parcer_assets.c
--- /tmp/tmp.TWsp1NfOBI/parcer/parcer_assets.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/parcer_assets.c	2025-04-07 18:14:48.062599552 +0300
@@ -0,0 +1,274 @@
+/**
+* @file parcer_assets.c
+* @brief В данном файле находятся  функции для парсинга аргументов, переданных программе.
+*/
+
+#include "parcer_assets.h"
+
+/**
+ * @brief Функция, которая устанавлениват режим орнамента.
+ * 
+ * Используется в функции парсера, для установки режима орнамента.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_pattern(char* optarg, object_t* figure) {
+    if (!strcmp(optarg, "rectangle")) figure->pattern = rectangle;
+    if (!strcmp(optarg, "semicircles")) figure->pattern = semicircle;
+    if (!strcmp(optarg, "circle")) figure->pattern = circle;
+
+    if (figure->pattern == none) {
+        fprintf(stderr, "Error: Вы выбрали несушествующий режим орнамента!\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --left_up.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_left_up(const char* optarg, object_t* figure) {
+    if (is_correct_dots(optarg, 1)) {
+        fprintf(stderr, "Error: Координаты переданы в некоректном формате!\n");
+        return 1;
+    }
+
+    int x, y;
+    int count_read = sscanf(optarg, "%d.%d", &x, &y);
+
+    if (count_read != 2) {
+        fprintf(stderr, "Error: координаты переданы в неправильном формате!\n");
+        return 1;
+    }
+
+    figure->x_left_up = x; figure->y_left_up = y;
+
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --right_down.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_right_down(const char* optarg, object_t* figure) {
+    if (is_correct_dots(optarg, 1)) {
+        fprintf(stderr, "Error: Координаты переданы в некоректном формате!\n");
+        return 1;
+    }
+
+    int x, y;
+    int count_read = sscanf(optarg, "%d.%d", &x, &y);
+
+    if (count_read != 2) {
+        fprintf(stderr, "Error: координаты переданы в неправильном формате!\n");
+        return 1;
+    }
+
+    figure->x_right_down = x; figure->y_right_down = y;
+
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --angle.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_angle(const char* optarg, object_t* figure) {
+    if (!is_number(optarg)) {
+        fprintf(stderr, "Error: вы ввели не число для --angle\n");
+        return 1;
+    }
+
+    int count_read = sscanf(optarg, "%d", &figure->angle);
+
+    if (count_read != 1) {
+        fprintf(stderr, "Error: Вы ввели неккоректное значение для --angle\n");
+        return 1;
+    }
+
+    if (figure->angle != 90 && figure->angle != 180 && figure->angle != 270) {
+        fprintf(stderr, "Error: Введёно неправильно значение для --angle должны быть 90 или 180 или 270.\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --count.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_count(const char* optarg, object_t* figure) {
+    if (!is_number(optarg)) {
+        fprintf(stderr, "Error: аргумент для --count должен быть числом!\n");
+        return 1;
+    }
+
+    int count_read = sscanf(optarg, "%d", &figure->count);
+
+    if (count_read != 1) {
+        fprintf(stderr, "Error: Вы ввели неккоректное значение для --count\n");
+        return 1;
+    }
+
+    if (figure->count <=0 ) {
+        fprintf(stderr, "Error: Введены отрицательные аргументы для --count\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --thickness.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_thickness(const char* optarg, object_t* figure) {
+    if (!is_number(optarg)) {
+        fprintf(stderr, "Error: вы ввели  не число для --thickness\n");
+        return 1;
+    }
+
+    int count_read = sscanf(optarg, "%d", &figure->thinckness);
+
+    if (count_read != 1) {
+        fprintf(stderr, "Error: Вы ввели неккоректное значение для --thinckness\n");
+        return 1;
+    }
+
+    if (figure->thinckness <= 0) {
+        fprintf(stderr, "Error: Неккоректный аргумент для --thickness, должно быть больше нуля!\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+bool parce_color(const char* optarg, object_t* figure) {
+    if (is_correct_dots(optarg, 2)) {
+        fprintf(stderr, "Error: Цвет передан в некоректном формате!\n");
+        return 1;
+    }
+
+    int red, green, blue;
+    int count_read = sscanf(optarg, "%d.%d.%d", &red, &green, &blue);
+
+    if (count_read != 3) {
+        fprintf(stderr, "Error: Вы ввели неккоректное значение для --color\n");
+        return 1;
+    }
+
+    if (check_colors(red, green, blue))
+        return 1;
+
+    figure->color_r = red; figure->color_g = green; figure->color_b = blue;
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --fill_color.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_fill_color(const char* optarg, object_t* figure) {
+    if (is_correct_dots(optarg, 2)) {
+        fprintf(stderr, "Error: Цвет передан в некоректном формате!\n");
+        return 1;
+    }
+
+    int red, green, blue;
+    int count_read = sscanf(optarg, "%d.%d.%d", &red, &green, &blue);
+
+    if (count_read != 3) {
+        fprintf(stderr, "Error: Вы ввели неккоректное значение для --fill_color\n");
+        return 1;
+    }
+
+    if (check_colors(red, green, blue))
+        return 1;
+
+    figure->color_fill_r = red; figure->color_fill_g = green; figure->color_fill_b = blue;
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --center.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_center(const char* optarg, object_t* figure) {
+    if (is_correct_dots(optarg, 1)) {
+        fprintf(stderr, "Error: Координаты переданы в некоректном формате!\n");
+        return 1;
+    }
+
+    int x, y;
+    int count_read = sscanf(optarg, "%d.%d", &x, &y);
+
+    if (count_read != 2) {
+        fprintf(stderr, "Error: координаты переданы в неправильном формате!\n");
+        return 1;
+    }
+
+    figure->x_center = x; figure->y_center = y;
+
+    return 0;
+}
+
+/**
+ * @brief Функция, которая парсит флаг --radius.
+ * 
+ * Используется в функции парсера.
+ * 
+ * @param optarg Переданный аргумент.
+ * @param figure Объект фигуры.
+ */
+bool parce_radius(const char* optarg, object_t* figure) {
+    if (!is_number(optarg)) {
+        fprintf(stderr, "Error: вы ввели  не число для --radius\n");
+        return 1;
+    }
+
+    int count_read = sscanf(optarg, "%d", &figure->radius);
+
+    if (count_read != 1) {
+        fprintf(stderr, "Error: Вы ввели неккоректное значение для --radius\n");
+        return 1;
+    }
+
+    if (figure->radius <= 0) {
+        fprintf(stderr, "Error: Неккоректный аргумент для --radius, должно быть больше нуля!\n");
+        return 1;
+    }
+
+    return 0;
+}
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/parcer_assets.h ./src/parcer/parcer_assets.h
--- /tmp/tmp.TWsp1NfOBI/parcer/parcer_assets.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/parcer_assets.h	2025-04-07 18:14:33.069016349 +0300
@@ -0,0 +1,17 @@
+#ifndef PARCER_ASSETS_H
+#define PARCER_ASSETS_H
+
+#include "parcer.h"
+
+bool parce_pattern(char*, object_t*);
+bool parce_left_up(const char*, object_t*);
+bool parce_right_down(const char*, object_t*);
+bool parce_angle(const char*, object_t*);
+bool parce_count(const char*, object_t*);
+bool parce_thickness(const char*, object_t*);
+bool parce_color(const char*, object_t*);
+bool parce_fill_color(const char*, object_t*);
+bool parce_center(const char*, object_t*);
+bool parce_radius(const char*, object_t*);
+
+#endif //PARCER_ASSETS_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/parcer.c ./src/parcer/parcer.c
--- /tmp/tmp.TWsp1NfOBI/parcer/parcer.c	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/parcer.c	2025-04-07 18:28:26.563226983 +0300
@@ -0,0 +1,153 @@
+/**
+* @file parcer.c
+ * @brief  Содержит главные функции для парсинга.
+ */
+
+#include "parcer.h"
+
+
+/**
+ * @brief Данная функция является логической функции парсера, которая проверяет все команды
+ * и передаёт их в зависимые функции.
+ *
+ * Данная функция является главной логической функцией, которая занимается парсингом всех переданных аргументов в
+ * программу. Она представляет собой инициализированный список флагов, а затем ветвистую стркутуру, которая
+ * в зависимости от считанного режима запускает выполнение того или иного флага.
+ * Используется в программе для парсинга аргументов.
+ *
+ * @param figure Указатель на объект.
+ * @param argc Количество аргументов.
+ * @param argv Список аргументов.
+ * @return Ноль если все хорошо, в ином случае код ошибки.
+ */
+int base_parser(object_t* figure, int argc, char** argv) {
+
+    if (argc == 1){
+        help_print();
+        return 1;
+    }
+
+    static struct option long_options[] = {
+        {"rect", no_argument, 0, 0},
+        {"ornament", no_argument, 0, 0},
+        {"rotate", no_argument, 0, 0},
+        {"circle", no_argument, 0, 0},
+        {"info", no_argument, 0, 0},
+        {"help", no_argument, 0, 'h'},
+        {"pattern", required_argument, 0, 'p'},
+        {"left_up", required_argument, 0, 'l'},
+        {"right_down", required_argument, 0, 'r'},
+        {"thickness", required_argument, 0, 't'},
+        {"output", required_argument, 0, 'o'},
+        {"input", required_argument, 0, 'i'},
+        {"fill", no_argument, 0, 'f'},
+        {"fill_color", required_argument, 0, 'F'},
+        {"angle", required_argument, 0, 'a'},
+        {"color", required_argument, 0, 'c'},
+        {"count", required_argument, 0, 'C'},
+        {"center", required_argument, 0, 'n'},
+        {"radius", required_argument, 0, 'R'},
+        {0, 0, 0, 0}
+    };
+
+    int opt, option_index = 0;
+
+    while ((opt = getopt_long(argc, argv, "hp:l:r:t:o:i:fF:a:c:C:n:R:", long_options, &option_index)) != -1) {
+        switch (opt) {
+            case 0:
+                if(set_mode(long_options[option_index].name, figure)){
+                    fprintf(stderr, "Error: Программа за один запуск может выполнить только одну функцию!\n");
+                    return 1;
+                }
+                break;
+
+            case 'h':
+                help_print();
+                return 2;
+
+            case 'p':
+                if (parce_pattern(optarg, figure)) return 1;
+                break;
+
+            case 'l':
+                if (parce_left_up(optarg, figure))
+                    return 1;
+                break;
+
+            case 'r':
+                if (parce_right_down(optarg, figure))
+                    return 1;
+                break;
+
+            case 'a':
+                if (parce_angle(optarg, figure))
+                    return 1;
+                break;
+
+            case 'i':
+                figure->start_filename = optarg;
+                break;
+
+            case 'o':
+                figure->finish_filename = optarg;
+                break;
+
+            case 'C': {
+                if (parce_count(optarg, figure))
+                    return 1;
+                break;
+            }
+            case 't': {
+                if (parce_thickness(optarg, figure))
+                    return 1;
+                break;
+            }
+            case 'c': {
+                if (parce_color(optarg, figure))
+                    return 1;
+                break;
+            }
+
+            case 'f':
+                figure->fill = true;
+                break;
+            case 'F':
+                if (parce_fill_color(optarg, figure))
+                    return 1;
+                break;
+
+            case 'n':
+                if (parce_center(optarg, figure))
+                    return 1;
+                break;
+
+            case 'R':
+                if (parce_radius(optarg, figure))
+                    return 1;
+                break;
+
+            case '?':
+                fprintf(stderr, "Error: Вы ввели неккоректную опцию!\n");
+                return 1;
+
+            default:
+                fprintf(stderr, "Error: Ошибка парсинга аргументов!\n");
+                return 1;
+        }
+    }
+
+    if (optind + 1 == argc && figure->start_filename == NULL) {
+        figure->start_filename = argv[optind];
+        return 0;
+    }
+
+
+    if (optind  < argc){
+        fprintf(stderr, "Error: Введены лишние аргументы!\n");
+        while (optind < argc)
+            fprintf(stderr, "Error: лишний аргумент - %s\n", argv[optind++]);
+        return 1;
+    }
+
+    return 0;
+}
\ В конце файла нет новой строки
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/parcer/parcer.h ./src/parcer/parcer.h
--- /tmp/tmp.TWsp1NfOBI/parcer/parcer.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/parcer/parcer.h	2025-04-07 18:22:34.870845389 +0300
@@ -0,0 +1,13 @@
+#ifndef PARCER_H
+#define PARCER_H
+
+#include "../structures.h"
+
+#include "parcer_assets.h"
+#include "additional.h"
+#include "help.h"
+
+
+int base_parser(object_t*, int, char** );
+
+#endif // PARCER_H
diff -ruN -p0 /tmp/tmp.TWsp1NfOBI/structures.h ./src/structures.h
--- /tmp/tmp.TWsp1NfOBI/structures.h	1970-01-01 03:00:00.000000000 +0300
+++ ./src/structures.h	2025-04-07 22:01:42.111279557 +0300
@@ -0,0 +1,162 @@
+/**
+* @file structures.h
+ * @brief Файл, где содержатся основные структуры и инклуды.
+ */
+
+#ifndef STRUCTURES_H
+#define STRUCTURES_H
+
+#include <stdio.h>
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <limits.h>
+#include <math.h>
+
+
+/**
+ * @file main.с
+ * @brief Весенняя курсовая работа
+ */
+
+
+/**
+ * @brief Перечисление режимов для орнамента.
+ *
+ * В данном перечислении находятся возможные режимы для создания орнамента, а также режим none, которые говорит о том,
+ * что поле структуры не инициализировано.
+ */
+typedef enum Pattern {rectangle, circle, semicircle, none} pattern_t;
+
+/**
+ * @brief Перечисление режимов допустимых операций.
+ *
+ * В данном перечислении находятся возможные режимы работы парсера, используются при инициализации полей структур,
+ * а также при ветвеленни, где происходит проверка поля на соответствие того или иного режима.
+ */
+typedef enum Mode {rect, ornament, rotate, circ, info, help, None} mode;
+
+typedef enum {
+    base_coords_val = INT_MIN,
+    base_color_val = -1,
+    base_thinckness_val = -1,
+    base_radius_val = -1,
+    base_count_val = -1,
+    base_angle_val = -1,
+} initial_values;
+
+typedef enum  {up = 1, down = -1} limit_circle_mod;
+
+
+#pragma pack(push, 1)
+/**
+* @breif Набор структур для чтения BMP
+*/
+typedef struct {
+    unsigned short signature;
+    unsigned int filesize;
+    unsigned short reserved1;
+    unsigned short reserved2;
+    unsigned int pixelArrOffset;
+} BitmapFileHeader;
+
+typedef struct {
+    unsigned int headerSize;
+    unsigned int width;
+    unsigned int height;
+    unsigned short planes;
+    unsigned short bitsPerPixel;
+    unsigned int compression;
+    unsigned int imageSize;
+    unsigned int xPixelsPerMeter;
+    unsigned int yPixelsPerMeter;
+    unsigned int colorsInColorTable;
+    unsigned int importantColorCount;
+} BitmapInfoHeader;
+
+typedef struct {
+    unsigned char b;
+    unsigned char g;
+    unsigned char r;
+} Rgb;
+
+#pragma pack(pop)
+
+
+/**
+ * @brief Структура, которая является собирательным образом всех параметров, которые нужны для
+ * работы каждого из режимов. Предполагается, что взаимодействие внутри программы происходит
+ * за счёт последовательной передачи объекта данной структуры.
+ *
+ * Данная структура включает все возможные поля для реализации всех режимов работы программы. Предполагается, что
+ * Взаимодействие частей программы происходит при передачи экземпляра данной структуры внутри программы. По сути,
+ * является классом данных, для более удобного формата хранения и взаимодействия с данными.
+ */
+
+typedef struct Object {
+    /** @brief Режим работы программы.*/
+    mode mod;
+
+    char* start_filename;                               /** @brief Имя файла, который нужно обработать.*/
+    char* finish_filename;                              /** @brief Имя файла, который должно быть после обработки.*/
+
+    int x_left_up, y_left_up;                           /** @brief Координаты левой верхней точки.*/
+    int x_right_down, y_right_down;                     /** @brief Координаты правой нижней точки.*/
+
+    int thinckness;                                     /** @brief Толшина линии.*/
+
+    int color_r, color_g, color_b;                      /** @brief Цвет линии.*/
+
+    bool fill;                                          /** @brief Нужно ли заливать фигуру.*/
+
+    int color_fill_r, color_fill_g, color_fill_b;       /** @brief Цвета заливки*/
+
+    pattern_t pattern;                                  /** @brief Режим для создания узора.*/
+
+    int count;                                          /** @brief Количество элементов узора.*/
+
+    int angle;                                          /** @brief Угол поворота части изображения.*/
+
+    int x_center, y_center;                             /** @brief Координаты центра окружности.*/
+    int radius;                                         /** @brief Радиус окружности*/
+} object_t ;
+
+/**
+ * @brief Используется при получении координат растровых фигут.
+ */
+typedef struct {
+    int x, y;
+} point_t;
+
+typedef struct {
+    int x_center, y_center;
+    int radius;
+    int thickness;
+    int len_array;
+    point_t* points;
+} circle_t;
+
+
+typedef struct {
+    int thickness;
+    point_t point_2;
+    point_t point_1;
+} line_t;
+
+
+/**
+ * @brief Функция конструктор заполняет структуру базовыми значениями, предполагается, что такие значения не могут
+ * получится в случае парсера, поэтому можно будет проверить, ввел ли пользователь тому или иному полю значение.
+ *
+ * Данная функция получая на вход структуру заполняет её поля некоторыми - невозможными значениями, для того чтобы
+ * при проверке структуры на корректность переданных аргументов можно было понять, было ли заполнено пользователем
+ * или иное поле. Используется при создании структуры для заполнения её базовыми значениями. Не всегда он нужен, тк
+ * иногда может заранее подразумеватся, что структура заполненна корректно.
+ *
+ * @param obj Объект, который нужно инициализировать.
+ */
+void constuctor(object_t*);
+
+#endif // STRUCTURES_H
